// _sys.rs or -sys.rs files are files which are only meant to be adaptations of C interfaces of C
// headers.
// Most of this header is taken from amcodec.h

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
use libc::{c_int, c_uint, c_ulong, c_ulonglong, c_void};

// const are equivalent to #DEFINE in C: they don't hold a place in memory,
// they are automatically replaced by the associated value every time this
// is found somewhere in the code
pub const FBIOGET_VSCREENINFO : i32 = 0x4600;
pub const FBIOPUT_VSCREENINFO : i32 = 0x4601;
pub const AMSTREAM_PORT_INIT: c_uint = 0x111;
pub const AMSTREAM_SET_VFORMAT: c_uint = 0x105;
pub const AMSTREAM_SET_TSTAMP: c_uint = 0x10E;
pub const EXTERNAL_PTS : c_ulong = 1;
pub const AMSTREAM_GET_EX_VB_STATUS : c_uint = 0x900;
pub const AMSTREAM_GET_EX_VDECSTAT : c_uint = 0x902;

// these are helpers which don't call ioctl by itself, but rather
// generate functions that call ioctl themselves.
// For instance this generates a function "amstream_ioc_get_version(fd: c_int, value: *mut value)"
// where value will have the AMSTREAM version right after this call.
ioctl!(read amstream_ioc_get_version with b'S', 0xc0; c_int);
ioctl!(bad fbio_get_vscreen_info with 0x4600);
ioctl!(bad fbio_set_vscreen_info with 0x4601);
ioctl!(write amstream_ioc_set with b'S', 0xc2; am_ioctl_parm);
ioctl!(write amstream_ioc_set_video_axis with b'S', 0x4c; c_int);
ioctl!(readwrite amstream_ioc_get with b'S', 0xc1; am_ioctl_parm);
ioctl!(readwrite amstream_ioc_get_vb_status with b'S', 0xc3; am_ioctl_parm_ex);

// ioc_sysinfo asks for a c_int BUT actually takes a struct
// don't ask me why, but don't change this to a struct instead,
// it doesn't work
ioctl!(write amstream_ioc_sysinfo with b'S', 0x0a; c_int);
ioctl!(write amstream_ioc_clear_video with b'S', 0x1f; c_int);
ioctl!(write amstream_ioc_vpause with b'S', 0x17; c_int);

// see fb_var_screeninfo at <linux/fb.h>
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct FbVarScreeninfo {
    pub xres: u32,
    pub yres: u32,
    pub xres_virtual: u32,
    pub yres_virtual: u32,
    pub xoffset: u32,
    pub yoffset: u32,
    pub bits_per_pixel: u32,
    pub grayscale: u32,
    pub red: FbBitfield,
    pub green: FbBitfield,
    pub blue: FbBitfield,
    pub transp: FbBitfield,
    pub nonstd: u32,
    pub activate: u32,
    pub height: u32,
    pub width: u32,
    pub accel_flags: u32,
    pub pixclock: u32,
    pub left_margin: u32,
    pub right_margin: u32,
    pub upper_margin: u32,
    pub lower_margin: u32,
    pub hsync_len: u32,
    pub vsync_len: u32,
    pub sync: u32,
    pub vmode: u32,
    pub rotate: u32,
    pub colorspace: u32,
    pub reserved: [u32; 4],
}

#[repr(C)]
pub struct dec_sysinfo_t {
    pub format: c_uint,  //< video format, such as H264, MPEG2...
    pub width: c_uint,   //< video source width
    pub height: c_uint,  //< video source height
    pub rate: c_uint,    //< video source frame duration
    pub extra: c_uint,   //< extra data information of video stream
    pub status: c_uint,  //< status of video stream
    pub ratio: c_uint,   //< aspect ratio of video source
    pub param: *mut c_void,   //< other parameters for video decoder
    pub ratio64: c_ulonglong,   //< aspect ratio of video source
}

pub type FbBitfield = fb_bitfield;
pub type BufStatus = buf_status;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct fb_bitfield {
    pub offset: u32,
    pub length: u32,
    pub msb_right: u32,
}

/* down below is automatically generated via rust-bindgen */
/* automatically generated by rust-bindgen */
pub const vformat_t_VFORMAT_UNSUPPORT: vformat_t = vformat_t::VFORMAT_MAX;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vformat_t {
    VFORMAT_UNKNOWN = -1,
    VFORMAT_MPEG12 = 0,
    VFORMAT_MPEG4 = 1,
    VFORMAT_H264 = 2,
    VFORMAT_MJPEG = 3,
    VFORMAT_REAL = 4,
    VFORMAT_JPEG = 5,
    VFORMAT_VC1 = 6,
    VFORMAT_AVS = 7,
    VFORMAT_SW = 8,
    VFORMAT_H264MVC = 9,
    VFORMAT_H264_4K2K = 10,
    VFORMAT_HEVC = 11,
    VFORMAT_H264_ENC = 12,
    VFORMAT_JPEG_ENC = 13,
    VFORMAT_VP9 = 14,
    VFORMAT_MAX = 15,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum aformat_t {
    AFORMAT_UNKNOWN = -1,
    AFORMAT_MPEG = 0,
    AFORMAT_PCM_S16LE = 1,
    AFORMAT_AAC = 2,
    AFORMAT_AC3 = 3,
    AFORMAT_ALAW = 4,
    AFORMAT_MULAW = 5,
    AFORMAT_DTS = 6,
    AFORMAT_PCM_S16BE = 7,
    AFORMAT_FLAC = 8,
    AFORMAT_COOK = 9,
    AFORMAT_PCM_U8 = 10,
    AFORMAT_ADPCM = 11,
    AFORMAT_AMR = 12,
    AFORMAT_RAAC = 13,
    AFORMAT_WMA = 14,
    AFORMAT_WMAPRO = 15,
    AFORMAT_PCM_BLURAY = 16,
    AFORMAT_ALAC = 17,
    AFORMAT_VORBIS = 18,
    AFORMAT_AAC_LATM = 19,
    AFORMAT_APE = 20,
    AFORMAT_EAC3 = 21,
    AFORMAT_PCM_WIFIDISPLAY = 22,
    AFORMAT_DRA = 23,
    AFORMAT_SIPR = 24,
    AFORMAT_TRUEHD = 25,
    AFORMAT_MPEG1 = 26,
    AFORMAT_MPEG2 = 27,
    AFORMAT_WMAVOI = 28,
    AFORMAT_UNSUPPORT = 29,
    AFORMAT_MAX = 30,
}

#[repr(C)]
pub struct am_ioctl_parm {
    pub union: am_ioctl_parm__bindgen_ty_1,
    pub cmd: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_char; 4usize],
}

#[repr(C)]
pub union am_ioctl_parm__bindgen_ty_1 {
    pub data_32: ::std::os::raw::c_uint,
    pub data_64: ::std::os::raw::c_ulonglong,
    pub data_vformat: vformat_t,
    pub data_aformat: aformat_t,
    pub data: [::std::os::raw::c_char; 8usize],
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vdec_type_t {
    VIDEO_DEC_FORMAT_UNKNOW = 0,
    VIDEO_DEC_FORMAT_MPEG4_3 = 1,
    VIDEO_DEC_FORMAT_MPEG4_4 = 2,
    VIDEO_DEC_FORMAT_MPEG4_5 = 3,
    VIDEO_DEC_FORMAT_H264 = 4,
    VIDEO_DEC_FORMAT_MJPEG = 5,
    VIDEO_DEC_FORMAT_MP4 = 6,
    VIDEO_DEC_FORMAT_H263 = 7,
    VIDEO_DEC_FORMAT_REAL_8 = 8,
    VIDEO_DEC_FORMAT_REAL_9 = 9,
    VIDEO_DEC_FORMAT_WMV3 = 10,
    VIDEO_DEC_FORMAT_WVC1 = 11,
    VIDEO_DEC_FORMAT_SW = 12,
    VIDEO_DEC_FORMAT_AVS = 13,
    VIDEO_DEC_FORMAT_H264_4K2K = 14,
    VIDEO_DEC_FORMAT_HEVC = 15,
    VIDEO_DEC_FORMAT_VP9 = 16,
    VIDEO_DEC_FORMAT_MAX = 17,
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct buf_status {
    pub size: ::std::os::raw::c_int,
    pub data_len: ::std::os::raw::c_int,
    pub free_len: ::std::os::raw::c_int,
    pub read_pointer: ::std::os::raw::c_uint,
    pub write_pointer: ::std::os::raw::c_uint,
}

impl Clone for buf_status {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct vdec_status {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub fps: ::std::os::raw::c_uint,
    pub error_count: ::std::os::raw::c_uint,
    pub status: ::std::os::raw::c_uint,
}

impl Clone for vdec_status {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct adec_status {
    pub channels: ::std::os::raw::c_uint,
    pub sample_rate: ::std::os::raw::c_uint,
    pub resolution: ::std::os::raw::c_uint,
    pub error_count: ::std::os::raw::c_uint,
    pub status: ::std::os::raw::c_uint,
}

impl Clone for adec_status {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct userdata_poc_info_t {
    pub poc_info: ::std::os::raw::c_uint,
    pub poc_number: ::std::os::raw::c_uint,
}

impl Clone for userdata_poc_info_t {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Copy)]
pub struct am_ioctl_parm_ex {
    pub union: am_ioctl_parm_ex_union,
    pub cmd: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_char; 4usize],
}

#[repr(C)]
#[derive(Copy)]
pub union am_ioctl_parm_ex_union {
    pub status: buf_status,
    pub vstatus: vdec_status,
    pub astatus: adec_status,
    pub data_userdata_info: userdata_poc_info_t,
    pub data: [::std::os::raw::c_char; 24usize],
}

impl Clone for am_ioctl_parm_ex_union {
    fn clone(&self) -> Self { *self }
}

impl Clone for am_ioctl_parm_ex {
    fn clone(&self) -> Self { *self }
}
